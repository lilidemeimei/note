* [垃圾回收](#垃圾回收)
* [PHP7新特性](#PHP7新特性)
* [设计模式](#设计模式)
* [问题](#问题)
#### 垃圾回收
##### PHP 5.3之前 
采用引用计数的方式管理内存，PHP 所有的变量存在一个叫 zval 的变量容器中，当变量被引用的时候，引用计数会+1，变量引用计数变为0时，PHP 将在内存中销毁这个变量。  
但是引用计数中的循环引用，引用计数不会消减为 0，就会导致内存泄露。  
zval包含变量的类型和值,is_ref(标识变量是否属于引用集合),refcount  
a: (refcount=1, is_ref=0)='new string'
##### PHP 5.3之后(回收周期)
1. 并不是每次引用计数减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收  
2. 可以解决循环引用问题  
3. 可以总将内存泄露保持在一个阈值以下。

#### PHP7新特性
1. 标量类型声明  
2. 返回值类型声明  
3. null合并运算符($username = $_GET['user'] ?? 'nobody';)  
4. 组合比较运算符 (当$a小于,等于或大于$b时它分别返回-1,0,1)  
   echo 1 <=> 1; // 0  
   echo 1 <=> 2; // -1  
   echo 2 <=> 1; // 1  
5. 通过define定义常量数组  
   define('ANIMALS', [  
     'dog',  
     'cat',  
     'bird'  
   ]);  
6. 匿名类  
7. Closure::call()  
8. 从同一namespace导入的类,函数,常量现在可以通过单个use语句一次性导入


#### 设计模式
##### 列举一些 PHP 中的设计模式？
1. 单例模式：保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个，同时这个类还必须提供一个访问该类的全局访问点。
2. 工厂模式：定义一个创建对象的接口，但是让子类去实例化具体类。工厂方法模式让类的实例化延迟到子类中。
3. 观察者模式：观察者模式有时也被称作发布/订阅模式，该模式用于为对象实现发布/订阅功能：一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作。
4. 适配器模式：适配器模式将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。
依赖注入模式：依赖注入（Dependency Injection）是控制反转（Inversion of Control）的一种实现方式。要实现控制反转，通常的解决方案是将创建被调用者实例的工作交由 IoC 容器来完成，然后在调用者中注入被调用者（通过构造器/方法注入实现），这样我们就实现了调用者与被调用者的解耦，该过程被称为依赖注入。
5. 门面模式：门面模式（Facade）又称外观模式，用于为子系统中的一组接口提供一个一致的界面。

#### 问题
##### Q1: GET和POST的区别?  
get : 查询字符串是在GET请求的URL中发送的  
post : 查询字符串是在post请求的http消息主体中发送的  

 |        | GET    |    POST |
 |--------|--------|---------|
 |后退按钮/刷新|无害(同一个请求方法执行多次和仅执行一次的效果完全相同)|数据会被重新提交|
 |书签   |可收藏为书签|不可收藏为书签|
 |缓存|能被缓存|不能被缓存|
 |编码类型|application/x-www-form-urlenchded|application/x-www-form-urlencoded或multipart/form-data.为二进制数据使用多重编码|
 |历史|参数保留在浏览器历史中|参数不会保留在浏览器历史中|
 |对数据长度的限制|当发送数据时,get方法向url添加数据,url长度受限制(根据浏览器或服务器的配置参数)|无限制(受服务器配置或内存大小)|
 |对数据类型的限制|只允许ascii字符|没有限制|
 |安全性|较差,因为所发送的数据是url的一部分|较安全,因为参数不会存在浏览器历史或web服务器日志中|
 |可见性|数据在url中对所有人都是可见的|数据不会显示在url中|  
 
##### Q2:单引号和双引号的区别?
1. 转义的字符不同  
单引号转义单引号和转义字符  
2. 对变量的解析不同  
双引号能解析变量,而单引号将变量名原样输出  
3. 解析速度不同  
单引号不需要考虑对变量的解析,速度比双引号快

##### Q3:isset和empty和is_null的区别?  
is_null判断变量是否为NULL  
isset 检测变量是否已设置并且非NULL  
empty     
* ""(空字符串)
- 0(作为整数的0)
* 0.0(作为浮点数的0)
- "0"(作为字符串的0)
* NULL
- FALSE
* array()(一个空数组)
- $var (一个声明了,但是没有值的变量)

##### Q4:echo,print,var_dump()和print_r()的区别?
1. echo和print  
共同点 : echo和print都不是函数,是语言结构,只能输出字符串,int,float数据,不能打印复合型和资源型数据  
区别 : echo 可以连续输出多个变量，而print只能一次输出一个变量。print打印的值能直接复制给一个变量，如 $a = print “123”;  
2. var_dump()和print_r()  
共同点 ：两者都可以打印数组，对象之类的复合型变量  
区别 : print_r()在打印数组时，会将把数组的指针移到最后边，使用 reset() 可让指针回到开始处,显示关于一个变量的易于理解的信息,var_dump显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。  

##### Q5:什么是MVC?

##### Q6:为什么 PHP7 比 PHP5 性能提升了？
1. 变量存储字节减小，减少内存占用，提升变量操作速度
2. 改善数组结构，数组元素和 hash 映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率
3. 改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率

##### Q7:如何解决 PHP 内存溢出问题?
1. 增大 PHP 脚本的内存分配  
2. 变量引用之后及时销毁  
3. 将数据分批处理

##### Q8:require和include的区别？
require和include几乎完全一样，包含并运行指定文件，除了处理失败的方式不同之外。require在出错时将导致脚本中止，而include只产生警告，脚本会继续运行。












