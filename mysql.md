## <<高性能MySQL>>

## 目录 
* [锁策略](#锁策略)
* [事务](#事务)
* [存储引擎](#存储引擎)
* [数据类型优化](#数据类型优化)
* [索引](#索引)
    * [索引类型](#索引类型)
    * [索引的优点](#索引的优点)
    * [高性能索引](#高性能索引)
* [SQL](#SQL)
 ### 锁策略 
 
表锁: 锁定整张表  
行级锁: 最大程度地支持并发处理(同时也带来了最大的锁开销)  
死锁: 两个或多个事务在同一资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环的现象
### 事务
一组原子性的SQL查询,或者说一个独立的工作单元.(事务内的语句,要么全部执行成功,要么全部执行失败)    
#### ACID:  
##### 原子性(atomicity[ˌætəˈmɪsɪti]):   
一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚.  
##### 一致性(consistency):  
数据库总是从一个一致性的状态转换到另一个一致性的状态  
##### 隔离性(isolation):  
通常来说,一个事务所做的修改在最终提交以前,对其他事务是不可见的.  
##### 持久性(durability[ˌdjʊrəˈbɪlətɪ]):  
一旦事务提交,则其所做的修改就会永久保存到数据库中.  

隔离级别:  
未提交读: 事务可以读取未提交的数据(脏读)  
提交读: 一个事务从开始直到提交之前,所做的任何修改对其他事务都是不可见的(不可重复读)  
可重复读: 保证了同一事务中多次读取同样记录的结果是一致的  
可串行化: 在读取每一行的数据上都加锁,可能导致大量的超时和锁争用问题  

  

### 存储引擎:
InnoDB,MyISAM,Archive,CSV,Memory
##### InnoDB存储引擎
InnoDB是MySQL的默认事务型引擎,支持崩溃自动恢复  
采用MVCC(多版本并发控制技术)支持高并发  
基于聚簇索引建立  
内部优化 : 可预测性读,自适应哈希索引(加速读操作),插入缓冲区(加速插入操作)
##### MyISAM存储引擎
不支持事务和行级锁,崩溃后无法安全恢复  
加锁与并发 : 对整张表加锁,有读取查询的同时可以往表中插入新的记录  
修复 : 可以自动或手动执行修复操作(这里的修复和事务恢复和崩溃修复是不同的概念)  
索引特性 : 即使是BLOB和TEXT等长字段,也可以基于其前500个字符创建索引.也支持全文索引  
延迟更新索引键 : 创建MyISAM表时,如果指定了DELAY_KEY_WRITE,不会立刻将修改的索引数据写入磁盘,而是会写到内存中的键缓冲区,只有在清理缓冲取或者关闭表的时候才会将对应的索引块写入到磁盘,这种方式可以极大地提升写入行能,但在数据库或主机崩溃时会造成索引损坏,需要执行修复操作  
* MyISAM压缩表
适合于 表在创建并导入数据以后,不会再进行修改操作.压缩表可以极大地减少磁盘空间占用,因此也可以减少磁盘I/O,从而提升查询性能.压缩表是独立压缩的,所以读取单行的时候不需要解压整个表



### 数据类型优化
1. 更小的通常更好 : 使用可以正确存储数据的最小数据类型
2. 简单就好 : 简单数据类型的操作通常需要更少的CPU周期
3. 尽量避免NULL
##### 整数类型
TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别使用8,16,24,32,64位存储空间,unsigned属性表示不允许负值,tinyint unsigned:0-255 tinyint:-128-127
##### 实数类型
浮点类型在存储同样范围的值时,通常比DECIMAL使用更少的空间
###### 字符串类型
VARCHAR类型用于存储可变长字符串.比定长更节省空间  
CHAR类型是定长的,适合存储很短的字符串或所有值都接近同一个长度  
BINARY,VARBINARY
##### BLOB和TEXT类型
都是为存储很大的数据而设计的字符串数据类型,分别采用二进制和字符方式存储
##### 日期和时间类型
DATATIME : 1001-9999年,与时区无关,使用8个字节存储空间 FROM_UNIXTIME()  
TIMESTAMP : 与unix时间戳相同,使用4个字节的存储空间,1970-2038 UNIX_TIMESTAMP()  

### 索引

#### 索引类型
索引在存储引擎层实现的  
一. B-Tree索引  
B-Tree的查询类型  
    所有值都是按顺序存储,可以用来做order by和group by操作.B-Tree索引适用于全键值,键值范围,或键前缀查找
    全值匹配:和索引中所有列进行匹配  
    匹配最左前缀:只使用索引的第一列  
    匹配列前缀:也可以只匹配某一列的值的开头部分  
    匹配范围值:例查找姓在Allen和Barrymore之间的人,这里也只使用了索引的第一列
    精确匹配某一列并范围匹配另外一列:索引的第一列全匹配,第二列范围匹配
    只访问索引的查询:查询只需要访问索引,而无须访问数据行  
 B-Tree索引的限制  
   如果不是按照索引的最左列开始查找,则无法使用索引  
   不能跳过索引中的列
   如果查询中有某个列的范围查询,则其右边所有的列都无法使用索引优化查找
二. 哈希索引 (Memory,NDB引擎支持)  
哈希索引基于哈希表实现,只有精确匹配索引所有列的查询才有效.对于每一行数据,存储引擎都会对所有的索引列计算一个哈希码,哈希码是一个较小的值,并且不同键值的行计算出来的哈希码也不一样.哈希索引将所有的哈希码存储在索引中,同时在哈希表中保存指向每个数据行的指针
哈希索引的限制:  
1. 哈希索引只包含哈希值和行指针,而不存储字段值,所以不能使用索引中的值来避免读取行.不过访问内存中的行的速度很快,所以大部分情况下这一点对性能的影响并不明显
2. 哈希索引数据并不是按照索引值顺序存储的,所以无法用于排序  
3. 不支持部分索引列匹配查找,因为哈希索引始终是使用索引列的全部内容来计算哈希值的.例如在数据列(A,B)上建立哈希索引,如果查询只有数据列A,则无法使用该索引
4. 只支持等值比较查询  
5. 哈希冲突很多时,索引的维护操作代价高  

三. 空间数据索引(R-Tree):从所有维度索引数据,即  查询时可以有效地使用任意维度来组合查询,必须使用MySQL的GIS相关函数来维护数据
四. 全文索引 : 它查找的是文本中的关键词,而不是直接比较索引中的值

### 索引的优点  
1.大大减少了服务器需要扫描的数据量  
2.帮助服务器避免排序和临时表  
3.将随机I/O变为顺序I/O  

### 高性能索引  
1.独立的列:索引列不能是表达式的一部分,也不能是函数的参数  
2.前缀索引和索引选择性:索引开始的部分字符,前缀应该足够长,以使得前缀索引的选择性接近于索引的整个列,mysql无法使用前缀索引做order by和group by,也无法使用前缀索引做覆盖扫描  
3. 多列索引  
4. 选择合适的索引列顺序  
当不需要考虑排序和分组时,将选择性最高的列放在前面通常是很好的.这时候索引的作用只是用于优化  
5. 聚簇索引: 当表有聚簇索引时,它的数据行实际上存放在索引的叶子页中.数据行和相邻的键值紧凑地存储在一起,一个表只能有一个聚簇索引  
6. 覆盖索引 : 一个索引包含所有需要查询的字段的值

### SQL
###### 显示表的相关信息
SHOW TABLE STATUS LIKE 'user'\G

### 索引与数据结构
B-Tree(多路搜索树)  
##### m阶B-Tree满足以下条件:  
1. 每个结点最多拥有m个子树(m>=2)  
2. 若根结点不是叶子结点,则最少有2个子树  
3. 分支结点最少拥有ceil(m/2)个子树(除根结点和叶子结点都是分支结点)  
4. 所有叶子结点都在同一层,叶子结点不包含任何关键字信息
5. 所有非终端结点中包含邪猎信息数据(n,A0,K1,A1,K2,A2,...,Kn,An),其中Ki(i=1,...,n)为关键字,且Ki<Ki+1,Ai(i=0,...,n)为指向子树根结点的指针,n为关键字的个数
##### B-tree插入 
每个非失败结点的关键字个数在[m/2-1, m-1]之间,如果在关键字插入后结点中的关键字个数超出了上界m-1,则结点需要"分裂",否则可以直接插入
设结点A中已经有m-1个关键字,当再插入一个关键字后结点中的状态为(m,A0,k1,A1,K2,A2,...,Km,Am)其中Ki<Ki+1,m>=1
这时必须把结点p分裂成两个结点p和q,将一半数量的关键字元素分裂到新的其相邻右结点中,中间关键字元素上移到父结点中,(如果父结点空间满了,也同样需要分裂)它们包含的信息为:  
结点p: (m/2-1, A0,K1,A1,...,Km/2-1,Am/2-1)
结点q: (m-m/2+1, Am/2,Km/2,)

