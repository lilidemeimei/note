## <<高性能MySQL>>

## 目录 
* [锁策略](#锁策略)
* [事务](#事务)
* [存储引擎](#存储引擎)
* [数据类型优化](#数据类型优化)
* [索引](#索引)
    * [索引类型](#索引类型)
    * [索引的优点](#索引的优点)
    * [高性能索引](#高性能索引)
 ### 锁策略 
 
表锁: 锁定整张表  
行级锁: 最大程度地支持并发处理(同时也带来了最大的锁开销)  
死锁: 两个或多个事务在同一资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环的现象
### 事务
一组原子性的SQL查询,或者说一个独立的工作单元.(事务内的语句,要么全部执行成功,要么全部执行失败)    
#### ACID:  
##### 原子性(atomicity[ˌætəˈmɪsɪti]):   
一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚.  
##### 一致性(consistency):  
数据库总是从一个一致性的状态转换到另一个一致性的状态  
##### 隔离性(isolation):  
通常来说,一个事务所做的修改在最终提交以前,对其他事务是不可见的.  
##### 持久性(durability[ˌdjʊrəˈbɪlətɪ]):  
一旦事务提交,则其所做的修改就会永久保存到数据库中.  

隔离级别:  
未提交读: 事务可以读取未提交的数据(脏读)  
提交读: 一个事务从开始直到提交之前,所做的任何修改对其他事务都是不可见的(不可重复读)  
可重复读: 保证了同一事务中多次读取同样记录的结果是一致的  
可串行化: 在读取每一行的数据上都加锁,可能导致大量的超时和锁争用问题  

  

### 存储引擎:
InnoDB,MyISAM,Archive,CSV,Memory

### 数据类型优化
1. 更小的通常更好 : 使用可以正确存储数据的最小数据类型
2. 简单就好 : 简单数据类型的操作通常需要更少的CPU周期
3. 尽量避免NULL
##### 整数类型
TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别使用8,16,24,32,64位存储空间,unsigned属性表示不允许负值,tinyint unsigned:0-255 tinyint:-128-127
##### 实数类型
浮点类型在存储同样范围的值时,通常比DECIMAL使用更少的空间
###### 字符串类型
VARCHAR类型用于存储可变长字符串.比定长更节省空间  
CHAR类型是定长的,适合存储很短的字符串或所有值都接近同一个长度


### 索引类型  
一. B-Tree索引  
二. 哈希索引 (Memory,NDB引擎支持)  
1. 无法用于排序  
2. 不能使用索引中的值来避免读取行  
3. 不支持部分索引列匹配查找  
4. 只支持等值比较查询  
5. 哈希冲突很多时,索引的维护操作代价高  

三. 空间数据索引(R-Tree):从所有维度索引数据  
四. 全文索引  

### 索引的优点  
1.大大减少了服务器需要扫描的数据量  
2.帮助服务器避免排序和临时表  
3.将随机I/O变为顺序I/O  

### 高性能索引  
1.独立的列:索引列不能是表达式的一部分,也不能是函数的参数  
2.前缀索引和索引选择性:索引开始的部分字符,前缀应该足够长,以使得前缀索引的选择性接近于索引的整个列,mysql无法使用前缀索引做order by和group by,也无法使用前缀索引做覆盖扫描  
3. 多列索引  
4. 选择合适的索引列顺序  
5. 聚簇索引  
6. 覆盖索引 : 一个索引包含所有需要查询的字段的值
